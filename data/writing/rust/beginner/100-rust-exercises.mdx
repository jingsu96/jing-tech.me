---
title: Rust - 100 Rust Exercises
date: '2024-05-20'
lastmod: '2024-05-24'
tags: ['rust']
draft: true
authors: ['default']
topic: '書籍'
root: true
---

<TOCInline toc={props.toc} asDisclosure />

## [100 Rust Exercises](https://rust-exercises.com/01_intro/00_welcome)

## Day 1

### 閱讀主題

[Syntax](https://rust-exercises.com/01_intro/01_syntax)

- [Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8a34855c07813667f7c95c5e9ac848c1)

### 程式碼

```rust
#[warn(dead_code)]
// `fn` <function_name> ( <input parameters> ) -> <return_type> { <body> }
fn greeting() -> &'static str {
    "Hello, World"
    // same as: return "Hello, World";
}

#[cfg(test)]
mod tests {
    use crate::greeting;

    #[test]
    fn test_greeting() {
        assert_eq!(greeting(), "Hello, World")
    }
}
```

### Takeaway

1. `&'static` 代表說這個字串是存在於程式的整個生命週期中，而不會被釋放。
2. `#[warn(dead_code)]` 這個屬性監測程式是否有未使用的程式碼，如果有的話會發出警告。
3. 如果沒有任何值被回傳，則回傳型別可是 `()`，也就是 `unit` 型別。
4. `#[cfg(test)]` 這個屬性代表說這個模組只有在執行測試時才會被編譯。

## Day 2

### 閱讀主題

[A Basic Calculator - Integers](https://rust-exercises.com/02_basic_calculator/01_integers)

### Primitive Types (基本型別)

`u32` 它代表一個 32 位元的非負整數，像是 `1`。其也是 Rust 其中一個基本型別，亦即內建型別，他們是語言的一部分，並解可以基於他們來建立其他型別。

Integer 可以分成兩種類型，有無符號 (unsigned) 與有符號 (signed)。

<div class="md:w-[50%]">
|  Type  | Size (bits) |              Range              |
| :----: | :---------: | :-----------------------------: |
|  `u8`  |      8      |         0 to \(2^8-1\)          |
| `u16`  |     16      |        0 to \(2^{16}-1\)        |
| `u32`  |     32      |        0 to \(2^{32}-1\)        |
| `u64`  |     64      |        0 to \(2^{64}-1\)        |
| `u128` |     128     |       0 to \(2^{128}-1\)        |
|  `i8`  |      8      |     \(-2^7\) to \(2^7 - 1\)     |
| `i16`  |     16      |  \(-2^{15}\) to \(2^{15} - 1\)  |
| `i32`  |     32      |  \(-2^{31}\) to \(2^{31} - 1\)  |
| `i64`  |     64      |  \(-2^{63}\) to \(2^{63} - 1\)  |
| `i128` |     128     | \(-2^{127}\) to \(2^{127} - 1\) |

</div>

- u 為 unsigned 的縮寫，i 為 integer 的縮寫。

#### 表示方式

除了常見的數字表示方式，我們也可以透過底線 `_` 來增加數字的可讀性。

```rust
let a: u32 = 42;
let one_million: u32 = 1_000_000;
```

#### 運算子

與大部分的程式語言一樣，Rust 也有基本的運算子，像是 `+`、`-`、`*`、`/`、`%`。

但是值得注意的是，當你使用 `/` 運算子時，如果兩個整數相除，則會得到一個整數，而不是浮點數。

```rust
let a = 5 / 2;
println!("{}", a); // 2
```

#### 沒有自動轉型

Rust 不會自動轉型，所以如果你想要將一個整數轉換成浮點數，你必須明確地轉換。

```rust
let a = 5;
let a_divided_by_2 = a as f64 / 2.0;
```

## Day 3

### 閱讀主題

[A Basic Calculator - Variables](https://rust-exercises.com/02_basic_calculator/02_variables)

#### 變數

在 Rust 可以使用 `let` 來宣告變數，而變數的型別可以是透過型別推論 (type inference) 或是開發者明確指定。

```rust
let x = 5; // 型別推論

// let <variable_name>: <type> = <expression>;
let y: i32 = 10; // 明確指定型別
```

什麼是型別推論呢？當你宣告變數時，Rust 會根據你的賦值來推斷變數的型別。

```rust
let x = 5;
let y: u32 = x;
```

Rust 不執行自動類型轉換，當編譯器推斷 x 的類型為 u32 ，與 y 相同，這是唯一一種允許程序在編譯時不出錯的類型。

#### 函式的型別不會自動推斷

在 Rust 中，函式的型別不會自動推斷，所以我們必須明確指定函式的型別。

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```

## Day 4

### 閱讀主題

[A Basic Calculator - Control Flow](https://rust-exercises.com/02_basic_calculator/03_if_else)

### If/Else

```rust
fn is_even(x: i32) -> bool {
    if x % 2 == 0 {
        true
    } else {
        false
    }
}

#[cfg(test)]
mod tests {
    use crate::is_even;

    #[test]
    fn one() {
        assert!(!is_even(1));
    }

    #[test]
    fn two() {
        assert!(is_even(2));
    }

    #[test]
    fn high() {
        assert!(!is_even(231));
    }
}
```

在 `if` 的條件式中，條件式所回傳值必須是一個布林值，否則會出現編譯錯誤。

```bash
error[E0308]: mismatched types
```

如同 Day 3 所提到的概念，Rust 奉行嚴格的類型強制轉換哲學：與 JavaScript 或 Python 這類動態類型語言不同，在 Rust 中，非布林類型不會自動轉換為布林值，也沒有真值或假值的概念。

#### If/Else 也是一個表達式

在 Rust 中，`if`/`else` 也是一個表達式，這意味著我們可以將 `if`/`else` 的結果賦值給一個變數。

```rust
let x = 5;

let is_x_even = if x % 2 == 0 {
    true
} else {
    false
};

println!("{}", is_x_even); // false
```

## Day 5

### 閱讀主題

[Panics](https://rust-exercises.com/02_basic_calculator/04_panics)

### Panics

在 Day 2 的作業中，我們寫了一個 `speed` 的函式

```rust
fn speed(start: u32, end: u32, time_elapsed: u32) -> u32 {
    let distance = end - start;
    distance / time_elapsed
}
```

但這裡函式的問題是當 `time_elapsed` 為 0 時，rust 會因為 `time_elapsed` 為 0，導致 `panic` 而中斷程式。

```bash
thread 'main' panicked at src/main.rs:3:5:
attempt to divide by Zero
```

**panic** 是 Rust 的一個錯誤處理機制，當程式遇到不可恢復的錯誤時，會中斷程式並顯示錯誤訊息。

### The panic! Macro

Rust 提供了一個 `panic!` 宏，可以讓我們在程式中顯示錯誤訊息並中斷程式。

```rust
fn speed(start: u32, end: u32, time_elapsed: u32) -> u32 {
    if time_elapsed == 0 {
        panic!("time_elapsed cannot be zero");
    }

    let distance = end - start;
    distance / time_elapsed
}
```

我們也可以透過 `Result` 讓錯誤是可以復原的，而 Result 的用法主要是在函式內透過 Ok 或 Err 來回傳結果，並用 pattern match 的方式來處理 `Result` 類型的回傳值。

```rust
fn speed(start: u32, end: u32, time_elapsed: u32) -> Result<u32, &'static str> {
    if time_elapsed == 0 {
        Err("time_elapsed cannot be zero")
    } else {
        let distance = end - start;
        Ok(distance / time_elapsed)
    }
}

fn main() {
    let result = match speed(0, 10, 0) {
        Ok(speed) => speed,
        Err(err) => {
            println!("{}", err);
            0
        }
    };
}
```
