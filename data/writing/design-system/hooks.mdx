---
title: Design System 101 - å¸¸è¦‹çš„ Hooks
date: '2023-09-26'
tags: ['è¨­è¨ˆç³»çµ±']
draft: false
authors: ['default']
topic: 'æ ¸å¿ƒæ¦‚å¿µ'
order: 4
---

<TOCInline toc={props.toc} asDisclosure />

## useSafeLayoutEffect

### ç”¨é€”

`useLayoutEffect` æ˜¯ React æä¾›çš„ä¸€å€‹ Hookï¼Œè·Ÿ `useEffect` ä¸€æ¨£ï¼Œéƒ½æ˜¯ç”¨ä¾†è™•ç† Side Effect çš„ï¼Œä¸åŒçš„æ˜¯ `useLayoutEffect` å…¶åŸ·è¡Œæ™‚é–“æ˜¯ç€è¦½å™¨ç¹ªè£½ DOM ä¹‹å‰ï¼Œä¸”åœ¨ SSR çš„æ™‚å€™ï¼Œæœƒå™´å‡ºéŒ¯èª¤ï¼š

```bash
Warning: useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://fb.me/react-uselayouteffect-ssr for common fixes.
```

ä¸»è¦æ˜¯å› ç‚º `useLayoutEffect` ä¸æœƒåœ¨ Server Side åŸ·è¡Œï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨ `useSafeLayoutEffect` ä¾†è§£æ±ºé€™å€‹å•é¡Œã€‚

è€Œ `useSafeLayoutEffect` çš„å¯¦ä½œï¼Œæ¦‚å¿µä¸Šå¾ˆç°¡å–®å°±æ˜¯å°‡ `useLayoutEffect` åœ¨ Server Side çš„æ™‚å€™ï¼Œæ”¹ç”¨ `useEffect` ä¾†åŸ·è¡Œã€‚

```JSX
import {useLayoutEffect, useEffect} from 'react';

const useSafeLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;
```

## useComposedRefs

> `useComposedRefs` é€šå¸¸æ˜¯ç”¨ä¾†åˆä½µå¤šå€‹ ref, è€Œé€™åœ¨ Design System ä¸­æ˜¯å¾ˆå¸¸è¦‹çš„ã€‚

ä¾‹å¦‚æœ‰æ™‚å¾Œæˆ‘å€‘çš„éœ€è¦åŒæ™‚æ§åˆ¶çµ„ä»¶å…§éƒ¨æŸå€‹å…ƒç´ ï¼Œä¸¦ä¸”ä¹Ÿèƒ½å¤ è®“å¤–éƒ¨é–‹ç™¼è€…ä¹Ÿèƒ½æ§åˆ¶é€™å€‹å…ƒç´ ã€‚é€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨ `useComposedRefs` ä¾†è§£æ±ºé€™å€‹å•é¡Œã€‚

èˆ‰ä¾‹ä¾†èªªï¼š

ç•¶é€™å€‹çµ„ä»¶ mounted (æ¸²æŸ“å®Œæˆ) çš„æ™‚å€™ï¼Œè‡ªå‹• focus åˆ°è¼¸å…¥æ¡†ä¸Šã€‚åŒæ™‚ï¼Œå¦‚æœä¹Ÿå¸Œæœ›è®“å…¶ä»–ä½¿ç”¨è€…å¯ä»¥æ‹¿åˆ°è¼¸å…¥æ¡†çš„å€¼ï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨ `useComposedRefs` ä¾†è§£æ±ºé€™å€‹å•é¡Œã€‚

<Sandpack>

```js file=App.js
import React, { forwardRef, useState, useEffect, useLayoutEffect, useRef } from 'react'
import { useComposedRefs } from './compose-refs'

const FocusableInput = forwardRef((props, externalRef) => {
  const internalRef = useRef()

  const composedRef = useComposedRefs(externalRef, internalRef)

  useEffect(() => {
    if (internalRef.current) {
      // internalRef.current.focus();
    }
  }, [])

  return <input ref={composedRef} {...props} />
})

export default () => {
  const inputRef = useRef(null)

  const handleButtonClick = () => {
    if (inputRef.current) {
      console.log('è¼¸å…¥æ¡†çš„å€¼æ˜¯', inputRef.current.value)
    }
  }

  return (
    <div>
      <FocusableInput ref={inputRef} placeholder="Placeholder" />
      <button onClick={handleButtonClick}>Submit</button>
    </div>
  )
}
```

```js file=compose-refs.js
import React, { useCallback } from 'react'

function assignRef(ref, value) {
  if (ref == null) {
    return
  }

  if (typeof ref === 'function') {
    ref(value)
  } else {
    Reflect.set(ref, 'current', value)
  }
}

export function useComposedRefs(...refs) {
  return React.useCallback(
    (value) => {
      refs.forEach((ref) => {
        assignRef(ref, value)
      })
    },
    [refs]
  )
}
```

</Sandpack>

## useCallbackRef

> `useCallbackRef` ä¸»è¦æ˜¯è¦è§£æ±ºå‚³å…¥å­çµ„ä»¶çš„ props ä¸æœƒå› ç‚ºçˆ¶å±¤çµ„ä»¶é‡æ–°æ¸²æŸ“ (re-render) é€²è€Œå°è‡´å­çµ„ä»¶ä¸å¿…è¦çš„æ¸²æŸ“ã€‚

ç‚ºäº†ç¢ºä¿å­çµ„ä»¶ä¸æœƒå› ç‚ºå…¶ä»–åŸå› è€Œé‡æ–°æ¸²æŸ“ï¼Œæˆ‘å€‘å¯ä»¥ä½¿ç”¨ `React.memo` ä¾†ç¢ºä¿å­çµ„ä»¶ä¸æœƒå› ç‚ºå…¶ä»–åŸå› è€Œé‡æ–°æ¸²æŸ“ï¼Œæ¥ä¸‹ä¾†é€éä¸‹é¢çš„ä¾‹å­ä¾†èªªæ˜ã€‚

é¦–å…ˆåœ¨çˆ¶å±¤å…ˆåŠ å…¥ count çš„ stateï¼Œä¸¦ä¸”åœ¨å­çµ„ä»¶ä¸­åŠ å…¥ä¸€å€‹ `renderCountRef` ä¾†è¨ˆç®—å­çµ„ä»¶é‡æ–°æ¸²æŸ“çš„æ¬¡æ•¸ã€‚

<Sandpack>

```js file=App.js
import React, { useState, useCallback, useRef, memo } from 'react'

const ChildComponenet = memo(({ callback }) => {
  const renderCountRef = useRef(0)

  renderCountRef.current++

  return (
    <div>
      <div>Child re-render: {renderCountRef?.current}</div>
    </div>
  )
})

export default () => {
  const [count, setCount] = React.useState(0)

  const callback = () => {
    console.log('count', count)
  }

  return (
    <>
      <h1>Without useCallbackRef</h1>
      <ChildComponenet callback={callback} />
      <button onClick={() => setCount((count) => count + 1)}>parent render: {count}</button>
    </>
  )
}
```

</Sandpack>

ç”±ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹åˆ°ï¼Œç•¶çˆ¶å±¤çµ„ä»¶é‡æ–°æ¸²æŸ“çš„æ™‚å€™ï¼Œå­çµ„ä»¶ä¹Ÿæœƒé‡æ–°æ¸²æŸ“ï¼Œé€™æ˜¯å› ç‚ºæ¯æ¬¡çˆ¶å±¤çµ„ä»¶é‡æ–°æ¸²æŸ“çš„æ™‚å€™ï¼Œæœƒé‡æ–°å»ºç«‹ä¸€å€‹æ–°çš„ callbackã€‚è€Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨ `useCallbackRef` ä¾†è§£æ±ºé€™å€‹å•é¡Œã€‚

<Sandpack>

```js file=App.js
import React, { useState, useCallback, useRef, memo } from 'react'
import { useCallbackRef } from './callback-ref'

const ChildComponenet = memo(({ callback }) => {
  const renderCountRef = useRef(0)

  renderCountRef.current++

  return (
    <div>
      <div>Child re-render: {renderCountRef?.current}</div>
    </div>
  )
})

export default () => {
  const [count, setCount] = React.useState(0)

  const callback = () => console.log(count)
  const stableCallback = useCallbackRef(callback)

  return (
    <>
      <h1>With useCallbackRef</h1>
      <ChildComponenet callback={stableCallback} />
      <button onClick={() => setCount((count) => count + 1)}>parent render: {count}</button>
    </>
  )
}
```

`useCallbackRef` ä¸»è¦æ˜¯å…ˆå°‡ callback å­˜åœ¨ `useRef` ä¸­ï¼Œä¸¦ä¸”é€é `useEffect` ä¾†æ›´æ–° callback çš„å€¼ï¼Œé€™æ¨£å°±å¯ä»¥ç¢ºä¿ callback ä¸æœƒå› ç‚ºçˆ¶å±¤çµ„ä»¶é‡æ–°æ¸²æŸ“è€Œé‡æ–°å»ºç«‹ã€‚

```js file=callback-ref.js
import React, { useRef, useEffect, useMemo } from 'react'

export function useCallbackRef(callback) {
  const callbackRef = useRef(callback)

  useEffect(() => {
    callbackRef.current = callback
  })

  return useMemo(
    () =>
      (...args) => {
        if (callbackRef.current) {
          return callbackRef.current(...args)
        }
      },
    []
  )
}
```

</Sandpack>

## useControlledState

åœ¨ Design System ä¸­ï¼Œè¨±å¤š UI éƒ½æœƒéœ€è¦ç®¡ç†ç•¶å‰ç‹€æ…‹ï¼Œåƒæ˜¯ checkbox çµ„ä»¶çš„ check èˆ‡ un-check, accordion çµ„ä»¶çš„å±•é–‹èˆ‡æ”¶åˆç­‰ç­‰ã€‚

è€Œé€™äº›ç‹€æ…‹é€šå¸¸éƒ½æ˜¯ç”±å¤–éƒ¨å‚³å…¥ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ç”±å…§éƒ¨æ§åˆ¶ï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨ `useControlledState` ä¾†è™•ç†é€™å€‹å•é¡Œã€‚

### API

è€Œé€šå¸¸çµ„ä»¶éœ€è¦åŒ…å«å¹¾ç¨®ç‹€æ…‹ï¼š

| Name               | Type     | Description                                                                        |
| ------------------ | -------- | ---------------------------------------------------------------------------------- |
| props.defaultValue | any      | çµ„ä»¶çš„åˆå§‹ç‹€æ…‹ï¼Œé€™ä¹Ÿæ˜¯çµ„ä»¶çš„é è¨­ç‹€æ…‹ï¼Œå¯ä»¥ä¸éœ€è¦ç¶“ç”±å¤–éƒ¨æ§åˆ¶ã€‚                     |
| props.value        | any      | çµ„ä»¶çš„ç•¶å‰ç‹€æ…‹ï¼Œç•¶å¤–éƒ¨æƒ³è¦å‚³å…¥ç‹€æ…‹å»æ§åˆ¶çµ„ä»¶æ™‚ï¼Œå°±å¯ä»¥å‚³å…¥ valueã€‚                 |
| props.onChange     | function | ç•¶å…¶ä»–é–‹ç™¼è€…æƒ³é€éç‹€æ…‹æ”¹è®Šæ™‚ï¼Œè™•ç†å…¶ä»–çš„é‚è¼¯ï¼Œé€™æ™‚å€™å°±å¯ä»¥å‚³å…¥ onChange callbackã€‚ |

### useUncontrolledState

åœ¨å¯¦ä½œ `useControlledState` ä¹‹å‰æˆ‘å€‘å…ˆå¯¦ä½œ `useUncontrolledState` ï¼Œå…¶å°±æ˜¯ `useState` åŠ ä¸Š `callback`ã€‚

```js
import { useState, useCallback, useRef } from 'react'
import { useCallbackRef } from './callback-ref'

export function useUncontrolledState({ defaultValue, onChange }) {
  const [value, setValue] = useState(defaultValue)
  const previousValueRef = useRef(value)
  const callback = useCallbackRef(onChange)

  useEffect(() => {
    if (value !== previousValueRef?.current) {
      callback(value)
      previousValueRef.current = value
    }
  }, [value, previousValueRef, onChange])

  return [value, setValue]
}
```

### useControlledState

ç•¶å¤–éƒ¨å‚³å…¥ value æ™‚ï¼Œå°±ä½¿ç”¨å¤–éƒ¨å‚³å…¥çš„ valueï¼Œå¦å‰‡å°±ä½¿ç”¨ `useUncontrolledState` çš„ defaultValueã€‚

```js
import { useCallback } from 'react'
import { useUncontrolledState } from './uncontrolled-state'
import { useCallbackRef } from './callback-ref'

const useControlledState = ({ defaultValue, value, onChange }) => {
  const [uncontrolledState, setUncontrolledState] = useUncontrolledState({
    defaultValue,
    onChange,
  })

  const isControlled = value != null
  const state = isControlled ? value : uncontrolledState
  const callback = useCallbackRef(onChange)

  const setState = useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue
        const v = typeof nextValue === 'function' ? setter(value) : nextValue
        if (v !== value) callback?.(v)
      } else {
        setUncontrolledState(nextValue)
      }
    },
    [value, isControlled, callback]
  )

  return [state, setState]
}
```

æ¥è‘—æˆ‘å€‘å°±å¯ä»¥é€éä¸‹é¢çš„ä¾‹å­ä¾†çœ‹ `useControlledState` å¦‚ä½•è™•ç†å¾å¤–éƒ¨å‚³å…¥çš„ç‹€æ…‹ï¼Œå…§éƒ¨ç‹€æ…‹ï¼Œä»¥åŠ onChange callbackã€‚

<Sandpack>

```js file=App.js
import React, { useState, useCallback, useRef, memo } from 'react'
import { useControlledState } from './controlled-state'

const Counter = ({ like, onChange, defaultLike }) => {
  const [likeCount, setLikeCount] = useControlledState({
    value: like,
    onChange,
    defaultValue: defaultLike,
  })
  return (
    <>
      <p>{likeCount}</p>
      <button onClick={() => setLikeCount(likeCount + 1)}>ğŸ‘</button>
    </>
  )
}

export default () => {
  const [like, setLike] = useState(0)

  return <Counter defaultLike={0} like={like} onChange={() => setLike(like + 1)} />
  // return <Counter defaultLike={0} />;
}
```

```js file=controlled-state.js
import { useCallback } from 'react'
import { useUncontrolledState } from './uncontrolled-state'
import { useCallbackRef } from './callback-ref'

export const useControlledState = ({ defaultValue, value, onChange }) => {
  const [uncontrolledState, setUncontrolledState] = useUncontrolledState({
    defaultValue,
    onChange,
  })

  const isControlled = value != null
  const state = isControlled ? value : uncontrolledState
  const callback = useCallbackRef(onChange)

  const setState = useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue
        const v = typeof nextValue === 'function' ? setter(value) : nextValue
        if (v !== value) callback?.(v)
      } else {
        setUncontrolledState(nextValue)
      }
    },
    [value, isControlled, callback]
  )

  return [state, setState]
}
```

```js file=uncontrolled-state.js
import { useState, useCallback, useRef, useEffect } from 'react'
import { useCallbackRef } from './callback-ref'

export function useUncontrolledState({ defaultValue, onChange }) {
  const [value, setValue] = useState(defaultValue)
  const previousValueRef = useRef(value)
  const callback = useCallbackRef(onChange)

  useEffect(() => {
    if (value !== previousValueRef?.current) {
      callback(value)
      previousValueRef.current = value
    }
  }, [value, previousValueRef, onChange])

  return [value, setValue]
}
```

```js file=callback-ref.js
import React, { useRef, useEffect, useMemo } from 'react'

export function useCallbackRef(callback) {
  const callbackRef = useRef(callback)

  useEffect(() => {
    callbackRef.current = callback
  })

  return useMemo(
    () =>
      (...args) => {
        if (callbackRef.current) {
          return callbackRef.current(...args)
        }
      },
    []
  )
}
```

</Sandpack>

## useMediaQuery

> `useMediaQuery` ä¸»è¦æ˜¯ç”¨ä¾†è™•ç† RWD çš„å•é¡Œï¼Œç•¶ç€è¦½å™¨çš„å¯¬åº¦æ”¹è®Šæ™‚ï¼Œå°±æœƒé‡æ–°è¨ˆç®— media query çš„çµæœã€‚

### API

| Name  | Type   | Description                                      |
| ----- | ------ | ------------------------------------------------ |
| query | string | media query çš„æ¢ä»¶ï¼Œä¾‹å¦‚ï¼š`'(min-width: 768px)'` |

### å¯¦ä½œ

é¦–å…ˆæˆ‘å€‘å¯ä»¥å…ˆé€é browse çš„ API `window.matchMedia` ä¾†å–å¾— media query çš„çµæœï¼Œåœ¨é€é `useCallback` ä¾†è¨‚é–±ç€è¦½å™¨çš„å¯¬åº¦è®ŠåŒ–ï¼Œæœ€å¾Œé€é `useSyncExternalStore` ä¾†åŒæ­¥ç‹€æ…‹ã€‚

```js
import { useCallback, useSyncExternalStore } from 'react';

export const useMediaQuery = (query: string) => {
  const subscribe = useCallback(
    (onChange) => {
      if (!canUseMatchMedia) {
        return;
      }
      const mq = window.matchMedia(query);
      mq.addEventListener('change', onChange);
      return () => mq.removeEventListener('change', onChange);
    },
    [query],
  );

  const getSnapshot = useCallback(() => (canUseMatchMedia ? window.matchMedia(query).matches : false), [query]);

  return useSyncExternalStore(subscribe, getSnapshot);
};
```

<Sandpack>

```js file=App.js
import React from 'react'
import { useMediaQuery } from './media-query'

export default () => {
  const isMobile = useMediaQuery('(max-width: 768px)')

  return <div>{isMobile ? 'Mobile' : 'Desktop'}</div>
}
```

```js file=media-query.js
import { useCallback, useSyncExternalStore } from 'react';

const canUseMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia !== 'undefined';

export const useMediaQuery = (query: string) => {
  const subscribe = useCallback(
    (onChange) => {
      if (!canUseMatchMedia) {
        return;
      }
      const mq = window.matchMedia(query);
      mq.addEventListener('change', onChange);
      return () => mq.removeEventListener('change', onChange);
    },
    [query],
  );

  const getSnapshot = useCallback(() => (canUseMatchMedia ? window.matchMedia(query).matches : false), [query]);

  return useSyncExternalStore(subscribe, getSnapshot);
};
```

</Sandpack>
