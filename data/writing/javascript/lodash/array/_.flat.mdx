---
title: 'lodash _.flat'
date: '2024-06-06'
tags: ['javascript']
draft: false
summary: lodash 函式庫中的 _.flat 函式
topic: '基本題型'
---

## 問題

`Array.prototype.flat()` 可以用來扁平陣列，可以參考 [MDN - Array.prototype.flat()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) 或是 [lodash - \_.flat()](https://lodash.com/docs/4.17.15#flat)。

```typescript
function flat(arr: Array<any>, depth: number): Array<any>
```

其主要參數有兩個：

1. `arr`：要扁平化的陣列。
2. `depth`：指定要扁平化的深度，預設為 `1`。

```javascript
const arr = [1, 2, [3, 4, [5, [6]]]]

flat(arr) // [1, 2, 3, 4, [5, [6]]]
flat(arr, 2) // [1, 2, 3, 4, 5, [6]]
flat(arr, Infinity) // [1, 2, 3, 4, 5, 6]
```

## 練習區

在了解問題後，可以嘗試先寫下你的思路，再到下方的練習區域實際寫出程式碼。

<Sandpack lang="static" activeFile="index.js">

```html file=index.html hidden=true
<style>
  body {
    font-family:
      noto sans,
      sans-serif;
  }

  table {
    width: 100%;
    border-collapse: collapse;
  }

  th,
  td {
    border: 1px solid #e2e2e3;
    padding: 8px;
    text-align: left;
  }

  th {
    background-color: #f2f2f2;
  }

  pre {
    margin: 0;
    font-family: consolas, monospace;
    font-size: 12px;
  }
</style>

<script src="view.js" type="module"></script>
```

```javascript file=index.js
/**
 * @param { Array } arr
 * @param { number } depth
 * @returns { Array }
 */
function flat(arr, depth = 1) {
  // your code here
}

export { flat }
```

```js file=view.js hidden=true
import { flat } from './index.js'

const testCases = [
  { input: [1, 2, [3, 4, [5, [6]]]], depth: 1, expected: [1, 2, 3, 4, [5, [6]]] },
  { input: [1, 2, [3, 4, [5, [6]]]], depth: 2, expected: [1, 2, 3, 4, 5, [6]] },
  { input: [1, 2, [3, 4, [5, [6]]]], depth: Infinity, expected: [1, 2, 3, 4, 5, 6] },
]

const createTestRow = (input, depth, expected) => {
  const output = flat(input, depth)
  const passed = JSON.stringify(output) === JSON.stringify(expected)
  return `
    <tr>
      <td><pre>${JSON.stringify(input)}${depth !== undefined ? `, ${depth}` : ''}</pre></td>
      <td><pre>${JSON.stringify(output)}</pre></td>
      <td>${passed ? '✅' : '❌'}</td>
    </tr>
  `
}

document.body.innerHTML = `
  <table>
    <thead>
      <tr>
        <th>輸入</th>
        <th>輸出</th>
        <th>通過</th>
      </tr>
    </thead>
    <tbody>
      ${testCases.map(({ input, depth, expected }) => createTestRow(input, depth, expected)).join('')}
    </tbody>
  </table>
`
```

</Sandpack>

## 追問

1. 如果你是用遞迴 (Recursion) 的方式來實踐，那是否可以也用迭代 (Iteration) 的方式來實踐？ 反之。

## 筆者的思路

### 遞迴 (Recursion)

1. 定義基本情況 (base case)，如果深度是 `0` 或者值不是一個陣列。
2. 迭代陣列中的每個項目。
3. 如果項目 (item) 是一個陣列且深度大於 `0`，那麼調用 `flat(item, depth - 1)` 。
4. 否則，我們將項目直接放入新陣列中。

### 迭代 (Iteration)

迭代的方式基本上就是模擬遞迴的行為，我們可以使用一個堆疊 (Stack) 來存放每個項目和深度，然後不斷地從堆疊中取出項目，直到堆疊為空。

1. 初始化堆疊：堆疊應該包含整個陣列及其初始深度。
2. 透過迴圈不斷地從堆疊中取出項目，直到堆疊為空。
3. 如果項目是一個陣列且深度大於 `0`，那麼將陣列中的每個項目都放入堆疊中。
4. 否則，將項目放入結果陣列中。

## 筆者的解答

### 遞迴 (Recursion)

#### 程式碼

```js
function flat(arr, depth) {
  // 1
  if (!depth || !Array.isArray(arr)) {
    return arr
  }

  const result = []

  arr.forEach((item) => {
    // 2
    if (Array.isArray(item) && depth > 0) {
      result.push(...flat(item, depth - 1)) // 3
    } else {
      result.push(item) // 4
    }
  })

  return result
}
```

#### 視覺化

可以想像成遞迴就是不斷地堆疊 (Stack)，每次調用 `flat` 函式就是將一個新的函式放入堆疊中，直到達到基本情況 (base case) 時，開始從堆疊中取出函式並執行。

```plaintext
flat([1, 2, [3, 4, [5, [6]]]], 2)
  flat([3, 4, [5, [6]]], 1)
    flat([5, [6]], 0)
      [5, [6]]
    [5, 6]
  [3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
```

### 迭代 (Iteration)

#### 程式碼

```js
function flat(arr, depth = 1) {
  const stack = arr.map((item) => [item, depth])
  let result = []

  while (stack.length > 0) {
    const [item, d] = stack.pop()

    if (Array.isArray(item) && d > 0) {
      stack.push(...item.map((subItem) => [subItem, d - 1]))
    } else {
      result.unshift(item)
    }
  }

  return result
}
```

#### 視覺化

```plaintext
flat([1, 2, [3, 4, [5, [6]]]], 2)
  stack: [[1, 2], [2, 2], [[3, 4, [5, [6]]], 2]]
  stack: [[1, 2], [2, 2], [3, 1], [4, 1], [[5, [6]], 1]]
  stack: [[1, 2], [2, 2], [3, 1], [4, 1], [5, 0], [[6], 0]]
  stack: [[1, 2], [2, 2], [3, 1], [4, 1], [5, 0], [6, 0]]
result: [1, 2, 3, 4, 5, 6]
```
