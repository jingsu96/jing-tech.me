---
title: '資料庫系統 - 資料庫儲存'
date: '2024-06-29'
tags: ['database-system']
draft: true
topic: '基本介紹'
---

## 前言

## 數據庫的文件系統

### 檔案儲存

### 頁面佈局 (Page Layout)

### 元組佈局 (Tuple Layout)

#### Tuple Oriented Storage

上次描述的內容，我會鬆散地稱之為元組導向存儲方案（tuple-oriented storage scheme），這實際上意味著，當我有一個元組（tuple）時，必須將它放在某處。頁面的佈局實際上是基於這種方式，比如說我有一個元組需要存儲。

在這個架構中，如果你想插入一個新的元組，你會查看頁面目錄（page directory）並找到在堆文件（heap files）中的某個帶有空槽的頁面。我們之前提到，頁面目錄會維護元數據（metadata），關於可用的空間。一旦我們找到要插入元組的頁面，就可以進行插入操作。

在這個元組導向存儲方案中，頁面目錄是至關重要的，因為它保存了每個頁面的元數據，包括頁面是否有空閒空間可供使用。當插入新的元組時，系統會首先查詢頁面目錄，找到適合放置元組的頁面。這種方法確保了存儲的有效性和查找的高效性。此外，為了優化性能，我們通常會使用緩存機制（caching mechanism）來加快頁面目錄的查詢速度，減少I/O操作的開銷。這些措施共同提高了整個系統的存儲和檢索效率，使得數據庫能夠在處理大量數據時依然保持高效運行。

然而，這種方法也存在一些問題。例如，當我們運行查詢時，必須實際查看數據，這可能會導致頁面內部的碎片化，因為一些頁面並未被充分利用。此外，頻繁的插入、更新和刪除操作會導致大量隨機的磁碟I/O，從而降低系統性能。在一些雲存儲系統中，如S3，我們無法進行就地更新，這使得元組導向存儲方案不適用。

因此，我們需要考慮其他潛在的方法來解決這些問題，例如日誌結構化存儲方案（log-structured storage scheme）。這種方法能夠解決上述問題，並提高系統的整體性能和效率。

#### Log Structured Storage

日誌結構化存儲方案（log-structured storage scheme）是我們在數據庫系統中採取的第二種最常見方法，在今天因為像 RocksDB 這樣的嵌入式存儲管理器（embedded storage manager）的普及而變得更加常見。

在日誌結構存儲中，我們維護一個日誌記錄（log record），用於記錄對元組（tuple）的更改，而不是像在面向元組（tuple-oriented）直接的存儲每個元組。日誌記錄包含兩種操作：`Put` 和 `Delete`。`Put` 記錄包含鍵值對 (key-value pair)，`Delete` 記錄則只包含要刪除的鍵。

該日誌紀錄中一開始會先存在 In Memory Page 中，當其滿了之後，會被寫入到磁盤中。而兩者的差異在於

In-Memory Page 的作用:

- 快速寫入:新的日誌記錄首先被寫入內存頁面，這比直接寫入磁盤要快得多。
- 批量處理:當內存頁面填滿時，整個頁面可以一次性寫入磁盤，這比逐條寫入更有效率。
- 減少磁盤 I/O:頻繁的小規模寫入會導致大量的磁盤 I/O 操作，而使用內存頁面可以將多次寫入合併為一次大的寫入操作。

Disk 存儲:

- 持久化:磁盤存儲確保數據在系統崩潰或斷電時不會丟失。
- 大容量:磁盤可以存儲遠超過內存容量的數據。
- 成本效益:相比內存，磁盤存儲更加經濟實惠，特別是對於大量數據。

儘管日誌結構存儲方案在某些方面比元組導向存儲方案更有效，但它的缺點也明顯

1. 讀取效率較低: 由於數據分散在日誌文件中，讀取操作可能需要掃描多個文件，這會增加查詢的時間。例如，當查詢一個鍵值對時，系統可能需要查找多個日誌文件，直到找到相應的數據。
2. 存進去的資料是無法更改的: 這樣會造成記憶體的負擔，因為 log 會一直增加，而無法刪除。

而我們可以透過建立索引與壓縮日誌來解決這些問題:

1. 為了提高讀取性能，系統會維護一個內存索引（in-memory index），記錄每個鍵的位置，無論是在內存緩衝區（In memory page）還是在磁盤（disk）上。
2. 系統會定期運行後台作業來壓實（compact）日誌，移除冗餘或過期的記錄。壓實後的日誌頁面被稱為有序字符串表（Sorted String Table，簡稱 SSTable）。SSTable 中的記錄按照鍵值排序，可以快速查找。

壓實有兩種方法:

1. 通用壓實（Universal Compaction）: 通用壓實的過程首先從初始狀態開始，系統中有多個已排序的日誌文件，這些文件包含按鍵值順序排列的數據條目。壓實過程會識別出包含冗餘或過期數據條目的較舊日誌文件，並將這些文件標記為待合併文件。接著，標記的日誌文件內容會被合併到一個新的已排序日誌文件中，在此過程中，會刪除不必要的記錄（例如舊版本的更新鍵值）。最後，原始日誌文件被刪除，留下較少數量但更大的已排序日誌文件，這些文件只包含最新的數據條目。
2. 分層壓實（Level Compaction）: 分層壓實與通用壓實類似，系統從已排序的日誌文件開始，這些文件按照年齡和大小組織成不同的層級。分層壓實從 Level 0 開始，這些文件經常被壓縮到 Level 1。這個過程涉及將 Level 0 的日誌文件合併到更少數量的 Level 1 日誌文件中，並刪除冗餘數據。隨著數據的積累，日誌文件會進一步壓縮到更高的層級（例如 Level 2，Level 3 等），每個層級包含更少但更大的日誌文件。這種層級結構有助於減少讀取操作時需要掃描的文件數量，提高查詢性能。

日誌結構存儲的優點是寫入速度非常快，因為只需要追加日誌。但是讀取速度可能會較慢，需要額外的工作來維護內存索引和定期壓實日誌。

其缺點

1. 寫放大（Write Amplification）：

- 壓縮過程會導致數據被多次寫入，增加了磁盤寫入量。
- 這可能會影響 SSD 的壽命，並增加 I/O 負擔。

2. 壓縮開銷：

- 定期進行的壓縮操作會消耗系統資源，可能影響整體性能。

一些現實中的例子：

- LevelDB 和 RocksDB 使用日誌結構存儲
- Cassandra 和 HBase 使用類似於 SSTable 的存儲格式
- Kafka 也使用類似的日誌結構進行消息存儲

要瞭解更多相關知識，可以參考以下資源：

- [LevelDB 的設計與實現](https://github.com/google/leveldb/blob/master/doc/impl.md)
- [Kafka 的日誌結構存儲設計](https://kafka.apache.org/documentation/#design_filesystem)
- [Cassandra 存儲引擎架構](https://cassandra.apache.org/doc/latest/architecture/storage_engine.html)

在日誌結構合併樹（Log-Structured Merge Tree, LSM Tree）中，"Level" 指的是存儲系統中的不同層級，用來組織和管理數據文件。每個層級代表了一組日誌文件，這些文件按照數據寫入的時間和壓縮過程被分配到不同的層級。

層級劃分是 LSM Tree 的核心概念之一。數據文件被組織成多個層級（Level），通常從 Level 0 開始。隨著數據文件的老化和累積，這些文件會被移動到更高的層級（例如 Level 1，Level 2 等）。每個層級包含的文件數量和大小會逐漸增加，這樣可以確保系統能夠有效地管理和存儲大量數據。

當新的數據寫入系統時，首先會被寫入到內存中的緩衝區（memtable）。當緩衝區滿時，數據會被轉寫到磁盤上的 Level 0。隨著時間的推移，Level 0 的文件會被合併並移動到 Level 1。在這個過程中，系統會刪除冗餘的數據條目，只保留最新的數據版本。這個合併和升級過程會在每個層級間不斷進行，從而形成一個層級金字塔結構。

層級結構的設計有助於提高查詢效率。當需要查詢數據時，系統可以快速定位到相應的層級，減少需要掃描的文件數量。更高的層級包含更大、更少的文件，這意味著查詢操作能夠更高效地進行，因為系統可以跳過不相關的層級和文件。

每個層級都有自己的壓縮策略，確保數據能夠被高效地存儲和管理。例如，Level 0 的文件可能會頻繁地合併和壓縮，而更高層級的文件則會較少進行這些操作，但每次操作的數據量會更大。

以 RocksDB 為例，它使用 LSM Tree 結構來管理數據。數據寫入流程如下：新數據寫入內存中的 memtable，當 memtable 滿時，數據被轉寫到磁盤上的 Level 0。Level 0 的文件會定期合併並升級到 Level 1，這個過程會持續進行，直到數據被移動到最終的高層級。每個層級的數據文件大小和數量都按照一定比例增長。例如，Level 0 可能包含多個小文件，而 Level 1 可能包含更大的合併文件。這種層級結構可以有效地管理數據寫入和查詢操作，保證系統的高效運行。

總之，層級（Level）在 LSM Tree 結構中扮演了關鍵角色，通過層級的劃分和管理，系統可以有效地處理大量數據，並保持高效的讀寫性能。
