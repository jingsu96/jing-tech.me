---
title: '[UX] 如何設計良好的 Submenu 使用者體驗'
date: '2024-05-08'
tags: ['user-experience']
draft: true
summary: 今天學 pointer-friendly submenu experience
---

Bad case: https://www.books.com.tw/
Good case: https://www.walmart.com/

## 問題

選單 (Menu) 組件主要是讓使用者能夠導覽功能的使用者介面，當需要呈現更詳細的子功能時，我們通常會在選單項目偵測到滑鼠移入時，顯示對應的子選單。

然而，在使用子選單時常會遇到這樣的問題：當使用者將游標從父層移向子選單時，如果途中觸發到了其他選單項目，就會造成其原本對應的子選單關閉，造成使用者體驗不佳。

|                                                      好的使用者體驗                                                      |                                                    不好的使用者體驗                                                     |
| :----------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------: |
| <Image width="354" height="268" className="mx-auto rounded-[12px]" src="/static/images/blog/ux/menu/good_example.gif" /> | <Image width="354" height="268" className="mx-auto rounded-[12px]" src="/static/images/blog/ux/menu/bad_example.gif" /> |

本篇文章將會探討如何解決這個問題，讓使用者在使用子選單時能夠有更好的體驗。

## 解決方案

### 改用點擊來觸發子選單開啟

使用點擊 (Click) 還是滑鼠移入 (Hover) 時來觸發選單已經是多年來討論的議題。

支持點擊派會覺得滑鼠移入會讓使用者時常不小心觸發了選單開啟，這會讓使用者覺得困惑。而支持滑鼠移入派則認為除了這是網頁常見的設計外，滑鼠移入可以讓使用者更快速的導覽，並且不需要多餘的點擊動作，這也是大多數使用者習慣的操作方式。

這時候可以和專案經理及設計師協商，看看是否能改用點擊來觸發子選單開啟。如果成功說服他們，就可以關掉這篇文章，早點下班！

### 預測游標的移動方向與速度

如果無法改用點擊來觸發子選單開啟，那麼接下來就來探討如何改善使用滑鼠移入的使用者體驗。

Adobe 的設計系統 React Specturm 有針對如何優化子選單使用者體驗，發表一篇部落格文章 [Creating a pointer-friendly submenu experience](https://react-spectrum.adobe.com/blog/creating-a-pointer-friendly-submenu-experience.html) 。

文內提到他們是透過預測游標的 **移動方向** 以及 **移動速度** 來判斷是否要關閉子選單。

在探討主要概念之前，要先知道如何定義有效移動，我們可以透過當前游標在頁面中的絕對座標向子選單中最高點與最低點各畫一條線，而得到的範圍就是有效移動的範圍。

<Image
  src="/static/images/blog/ux/menu/valid_area_dark.png"
  className="hidden rounded-[12px] dark:block"
  alt="valid area"
  width="451"
  height="324"
/>

<Image
  src="/static/images/blog/ux/menu/valid_area_light.png"
  className="rounded-[12px] dark:hidden"
  alt="valid area"
  width="451"
  height="324"
/>

#### 移動方向

定義出有效的移動範圍後，接下來就來探討如何計算出游標的移動方向。

接下來我們需要計算出三個角度：

1. `Θ top` ：由先前指針位置到子菜單內部頂部角形成的角度。
2. `Θ bottom` ：由前一指針位置到子選單底部內角形成的角度。
3. `Θ pointer` ：由前一指針位置到當前指針位置形成的角度（增量）。

有效移動範圍內的角度應該要在 `Θ top` 與 `Θ bottom` 之間，如果 `Θ pointer` 在這個範圍內，則表示游標在有效範圍內，反之則表示游標不在有效範圍內，即可關閉子選單。

<Image src="/static/images/blog/ux/menu/angle.png" alt="valid angle" width="451" height="324" />

移動角度可以透過 `Math.atan2` 將兩點的座標差值轉換成弧度，如下：

```javascript
// 座標差值
const { clientY: y, clientX: x } = evt
const deltaX = x - lastX
const deltaY = lastY - y
const theta = Math.atan2(deltaY, deltaX)
const angle = (theta * 180) / Math.PI
```

而 `angle` 的值在不同的移動方向會有不同的角度，舉例來說，當滑鼠往上移動時，角度為 90°。

<div class="w-fit">

| 滑鼠移動方向 | 角度          |
| ------------ | ------------- |
| 右           | 0°            |
| 上           | 90°           |
| 左           | -180° 或 180° |
| 下           | -90°          |

</div>

只要 `angle` 的值在有效範圍內，就會將父層選單的 `pointer-events` 設為 `none`，這樣就可以避免在移動過程中觸發其他選單項目而導致子選單關閉。

<Sandpack lang="static">

```html file=index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pointer Angle Calculation</title>
    <style>
      h1 {
        font-size: 1rem;
      }
      section {
        font-family: Helvetica, sans-serif;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        font-size: 1.5rem;
        position: relative;
      }

      output {
        position: absolute;
      }
    </style>
  </head>
  <body>
    <section>
      <div
        style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; border-radius: 50%; border: 1px solid #000;"
      >
        <div style="position: absolute; top: -40%; left: 50%; transform: translateX(-50%);">
          90°
        </div>
        <div style="position: absolute; top: 50%; left: 120%; transform: translateY(-50%);">0°</div>
        <div style="position: absolute; top: 120%; left: 50%; transform: translateX(-50%);">
          -90°
        </div>
        <div style="position: absolute; top: 50%; left: -40%; transform: translateY(-50%);">
          180°
        </div>
      </div>

      <div id="output" class="output"></div>
    </section>

    <script>
      const output = document.querySelector('.output')
      let lastX = null
      let lastY = null
      let isThrottled = false
      const throttleDuration = 100 // 節流間隔，單位是毫秒

      const handleMouseMove = (evt) => {
        const x = evt.clientX
        const y = evt.clientY

        if (lastX !== null && lastY !== null) {
          // Get delta values
          const deltaX = x - lastX
          const deltaY = lastY - y

          // Calculate the angle between the previous and current mouse positions
          const theta = Math.atan2(deltaY, deltaX)

          // Convert to degrees
          let angle = (theta * 180) / Math.PI

          output.innerHTML = `Angle: ${angle.toFixed(2)}°`
        }

        // Update last mouse position
        lastX = x
        lastY = y
      }

      const throttledMouseMove = (evt) => {
        if (!isThrottled) {
          handleMouseMove(evt)
          isThrottled = true
          setTimeout(() => {
            isThrottled = false
          }, throttleDuration)
        }
      }

      window.addEventListener('mousemove', throttledMouseMove)
    </script>
  </body>
</html>
```

</Sandpack>

#### 移動速度

為了預測使用者的意圖，我們還需要知道指針的速度。以下是我們知道的一些關於用戶如何移動他們的指針的事情：

1. [行動] 使用者通常在移動到子菜單時加速其指針，然後在到達目標時減速。
2. [預覽] 使用者有時會停止或減慢指針的速度以瀏覽子菜單中的選項。
3. 移動游標的速度
   - 目標距離游標越長，則移動游標的速度會越快 (Fitts's Law)
   - 當需要穿越較大 “通道” (Tunnel) 時更快地移動他們的指標 (Steering Law)

我們可以使用超時機制：如果指針在一段時間內沒有移動，且不再位於子菜單的父菜單項上，我們就可以假設用戶不再打算前往子菜單。

這個超時可以在每次指針移動後重置。因為有運動障礙的用戶可能需要更多時間移動指針，我們應該使用較大的超時值。

<Sandpack lang="static">

```html file=index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Submenu Example</title>
    <style>
      .menu {
        position: relative;
        width: 5rem;
        display: inline-block;
        background-color: #fecaca; /* bg-red-100 */
      }
      .menu-item {
        display: inline-block;
        position: relative;
      }
      .submenu {
        position: absolute;
        width: 5rem;
        visibility: hidden;
        background-color: #c6f6d5; /* bg-green-100 */
      }
      .menu:hover .submenu,
      .menu-item:hover .submenu {
        visibility: visible;
      }
      .submenu-item {
        position: relative;
      }
      .submenu-item-content {
        position: absolute;
        top: 0;
        left: 5rem;
        visibility: hidden;
      }
      .submenu-item:hover .submenu-item-content {
        visibility: visible;
      }
    </style>
  </head>
  <body>
    <!doctype html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Submenu Example</title>
        <link rel="stylesheet" href="Submenu.module.css" />
      </head>
      <body>
        <div class="menu">
          <div class="menu-item">Menu</div>
          <div class="submenu">
            <div class="menu-item">Item1</div>
            <div class="submenu-item">
              <div class="menu-item">Menu</div>
              <div class="submenu-item-content submenu">
                <div class="menu-item">Item1</div>
                <div class="menu-item">Item2</div>
                <div class="menu-item">Item3</div>
              </div>
            </div>
            <div class="menu-item">Item2</div>
            <div class="menu-item">Item3</div>
          </div>
        </div>
      </body>
    </html>
  </body>
</html>
```

</Sandpack>

## 參考資料

1. [Adobe | Creating a pointer-friendly submenu experience](https://react-spectrum.adobe.com/blog/creating-a-pointer-friendly-submenu-experience.html)
2. [Amazon | Breaking down Amazon’s mega dropdown](https://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown)
